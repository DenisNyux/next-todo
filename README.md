## Приложение список задач

Frontend часть приложения, написанная на Next.js 14.1.0. 

Backend написан при помощи Strapi. Это headless CMS. Я использовал ее, т.к. в ней можно быстро и удобно через дашборд создать API. Ссылка на репозиторий – [Strapi](https://github.com/DenisNyux/todo-strapi-backend)

Для того чтобы развернуть это приложение локально необходимо указать .env переменную со ссылкой на api, в формате:

```bash
API_URL="Url бэкенд-сервера"
```

## Структура приложения

Исходный код приложения я разделил по следующей структуре:

- [/app](#app) - основные страницы приложения в соответсвии с файловой системой Next.js
- [/components](#components) - компоненты, которые используются на странице
- [/сontexts](#contexts) - React контексты
- [/hooks](#hooks) - кастомные хуки
- [/modals](#modals) - модальные окна
- [/requests](#requests) - запросы к внешнему API
- [/utils](#utils) - вспомогательные функции

## /app

У приложения два роута: / – на нем выводятся все задачи, и /archived – страница с уже закрытыми задачами.  

Присутствует динамический маршрут для вывода страницы заметки – [todoId], а также маршрут /api 

### /api

В моем приложении самый часто отправляемый запрос – на получние всех задач. Так как пользователь должен иметь возможность управлять отображением задач (фильтрация, сортировка, кол-во заметок на странице), то я решил не вызывать его напрямую, а сначала отправлять запрос на роут /api. Такой подход рекомендует [официальная документация](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#fetching-data-on-the-client-with-route-handlers). Аналогичным образом настроен запрос на изменение задачи, в момент когда мы пометили ее как завершенную, совершается PUT запрос к роуту /api.

В /api лежит Route Handler, который принимает GET и PUT запросы с их параметрами и передает их в функцию из /requests, делающую запрос к внешнему api.

## /components

В этой папке лежат все компоненты моего приложения. Я старался использовать серверные компоненты, но те, что требовали частого ререндера или использования контекста, я сделал клиентскими. 

## /contexts

Моё приложение использует context API. Разворачивание полноценного state менеджера я посчитал нецелесообразным, т.к. я не планировал передавать большое кол-во данных между компонентами. В основном, данные передавались между компонентами TodoControls и TodoTable. Всего у меня используется два контекста: 

- filterContext – необходим для того, чтобы передавать параметры фильтрации и сортировки. 
- pagination – необходим для передачи параметров пагинации.

В контекст я обернул все компоненты на главной странице и странице с закрытыми задачами. 

## /hooks

В своем приложении я использовал один кастомный хук, который отслеживает, что компонент рендерится впервые и позволяет не отправлять многочисленные PUT запросы по каждому из выведенных задач. Они отправлялись, т.к. дефолтное значение чекбокса о том что задача сделана было записано в стейте.

## /modals
Здесь содержатся модальные формы для создания и изменения задачи. Формы отправляются при помощи [server actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations). В них настроена минимальная валидация, на то, что отправляемые значения не пустые. 

## /requests

Тут находятся все запросы которые я отправляю к внешнему API, а также типы по которым я проверяю параметры запроса и ответ сервера. Всего я отправляю три вида запросов: GET, PUT, POST

## /utils

Вспомогательные функции, которые служат для преобразования данных, получаемых с внешнего API.

## Внешний вид и стили

Для стилизации я использовал библиотеку Bootstrap компонентов для react и css modules. Приложение адаптирована под мобильные экраны и планшеты.